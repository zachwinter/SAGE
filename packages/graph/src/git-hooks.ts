import { spawn } from 'child_process';
import { promises as fs } from 'fs';
import { dirname, basename } from 'path';
import { err } from '@sage/utils';

export interface GitCommitResult {
  success: boolean;
  commitHash?: string;
  error?: Error;
}

export interface GitCheckoutResult {
  success: boolean;
  databasePath?: string;
  error?: Error;
}

/**
 * Git integration for database versioning.
 * Handles committing database snapshots and checking out historical states.
 */
export class GitDatabaseManager {
  private readonly projectRoot: string;
  private readonly debug: boolean;

  constructor(projectRoot: string, debug = false) {
    this.projectRoot = projectRoot;
    this.debug = debug;
  }

  /**
   * Commit database file to git after successful ingestion.
   */
  async commitDatabase(
    databasePath: string,
    commitHash: string,
    message?: string
  ): Promise<GitCommitResult> {
    try {
      // Check if we're in a git repository
      const isGitRepo = await this.isGitRepository();
      if (!isGitRepo) {
        if (this.debug) {
          console.log('Not in a git repository, skipping database commit');
        }
        return { success: true }; // Non-critical - continue without git
      }

      // Add database file to staging
      await this.runGitCommand(['add', databasePath.replace(this.projectRoot + '/', '')]);

      // Create commit with metadata
      const commitMessage = message ?? `Graph database snapshot for commit ${commitHash}

Generated by @sage/graph
Project commit: ${commitHash}
Database: ${basename(databasePath)}`;

      const result = await this.runGitCommand(['commit', '-m', commitMessage]);
      
      // Extract commit hash from git output
      const hashMatch = result.match(/\[.+?\s+([a-f0-9]+)\]/);
      const newCommitHash = hashMatch?.[1];

      if (this.debug) {
        console.log('Database committed to git:', newCommitHash);
      }

      return {
        success: true,
        commitHash: newCommitHash,
      };
    } catch (error) {
      // Non-critical error - don't fail ingestion
      if (this.debug) {
        console.error('Git commit failed:', error);
      }
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
      };
    }
  }

  /**
   * Checkout database file from a specific commit for querying.
   * Returns path to temporary database file.
   */
  async checkoutDatabaseAtCommit(
    databasePath: string,
    commitHash: string
  ): Promise<GitCheckoutResult> {
    try {
      // Create temporary file for historical database
      const tempDbPath = `${databasePath}.${commitHash.slice(0, 8)}.tmp`;
      
      // Try to extract database from git
      try {
        await this.runGitCommand(['show', `${commitHash}:${databasePath}`], tempDbPath);
      } catch (error) {
        // If direct path doesn't work, try relative to project root
        const relativePath = databasePath.replace(this.projectRoot + '/', '');
        await this.runGitCommand(['show', `${commitHash}:${relativePath}`], tempDbPath);
      }

      // Verify the file was created
      const exists = await fs.access(tempDbPath).then(() => true).catch(() => false);
      if (!exists) {
        throw new Error('Failed to extract database from git');
      }

      return {
        success: true,
        databasePath: tempDbPath,
      };
    } catch (error) {
      return {
        success: false,
        error: err(
          'EIO',
          `Failed to checkout database at commit ${commitHash}: ${error instanceof Error ? error.message : String(error)}`
        ),
      };
    }
  }

  /**
   * Clean up temporary database files created during historical queries.
   */
  async cleanupTempDatabases(databasePath: string): Promise<void> {
    try {
      const dbDir = dirname(databasePath);
      const dbName = basename(databasePath);
      const files = await fs.readdir(dbDir);
      
      // Find temp files matching pattern: dbname.{hash}.tmp
      const tempFiles = files.filter(file => 
        file.startsWith(dbName) && file.includes('.tmp')
      );
      
      await Promise.allSettled(
        tempFiles.map(file => fs.rm(`${dbDir}/${file}`, { force: true }))
      );

      if (this.debug && tempFiles.length > 0) {
        console.log(`Cleaned up ${tempFiles.length} temporary database files`);
      }
    } catch (error) {
      // Non-critical - just log if debug
      if (this.debug) {
        console.error('Cleanup failed:', error);
      }
    }
  }

  /**
   * Check if current directory is in a git repository.
   */
  async isGitRepository(): Promise<boolean> {
    try {
      await this.runGitCommand(['rev-parse', '--git-dir']);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get current git commit hash.
   */
  async getCurrentCommitHash(): Promise<string | null> {
    try {
      const result = await this.runGitCommand(['rev-parse', 'HEAD']);
      return result.trim();
    } catch {
      return null;
    }
  }

  /**
   * Check if there are uncommitted changes that might affect database state.
   */
  async hasUncommittedChanges(): Promise<boolean> {
    try {
      const result = await this.runGitCommand(['status', '--porcelain']);
      return result.trim().length > 0;
    } catch {
      return false; // Assume no changes if git fails
    }
  }

  /**
   * Check if a specific commit has already been ingested.
   */
  async isCommitIngested(commitHash: string): Promise<boolean> {
    try {
      const logMessage = `Graph database snapshot for commit ${commitHash}`;
      const result = await this.runGitCommand(['log', '--all', '--grep', logMessage]);
      return result.trim().length > 0;
    } catch (error) {
      if (this.debug) {
        console.error('Error checking if commit is ingested:', error);
      }
      return false;
    }
  }

  private async runGitCommand(args: string[], outputFile?: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const process = spawn('git', args, {
        cwd: this.projectRoot,
        stdio: outputFile ? ['pipe', 'pipe', 'pipe'] : ['pipe', 'pipe', 'pipe'],
      });

      let stdout = '';
      let stderr = '';

      if (outputFile) {
        // Redirect stdout to file for git show operations
        const fs = require('fs');
        const outputStream = fs.createWriteStream(outputFile);
        process.stdout.pipe(outputStream);
      } else {
        process.stdout.on('data', (data) => {
          stdout += data.toString();
        });
      }

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        if (code === 0) {
          resolve(stdout);
        } else {
          reject(new Error(`Git command failed with code ${code}: ${stderr}`));
        }
      });

      process.on('error', (error) => {
        reject(new Error(`Failed to spawn git process: ${error.message}`));
      });
    });
  }
}

/**
 * Simplified git utilities for basic operations.
 */
export const gitUtils = {
  /**
   * Get current commit hash in a project directory.
   */
  async getCurrentCommit(projectPath: string): Promise<string | null> {
    const manager = new GitDatabaseManager(projectPath);
    return manager.getCurrentCommitHash();
  },

  /**
   * Check if project has uncommitted changes.
   */
  async hasChanges(projectPath: string): Promise<boolean> {
    const manager = new GitDatabaseManager(projectPath);
    return manager.hasUncommittedChanges();
  },
};